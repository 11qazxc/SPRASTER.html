<html>
<head><title>Attempt to replicate SP Rastermatic with DHTML.</title><meta charset="UTF-8"><meta name="author" content="11qazxc"><meta name="date" content="2022-11-04"><link rel="license" href="https://www.gnu.org/licenses/gpl-3.0.html">
<div style="font-size:5px;color:#0008;">This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.<br />
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.<br />
You should have received a copy of the GNU GPL along with this program but i don't see where i can put it. See https://www.gnu.org/licenses/ .</div>
<img src="https://www.gnu.org/graphics/gplv3-or-later-sm.png" width="40px" />
</head>
<body onload="document.getElementById('canvas').height=50">
    <p><a href="https://github.com/hpgbproductions/SPRASTER">Original program</a> was made by <a href="https://www.simpleplanes.com/u/hpgbproductions">hpgbproductions</a>.</p><br />Note that it's output (last text field) is label's designText (i.e. code), it can't write subassembly file.<br />You can paste link (sometimes it doesn't works because of CORS, in such cases you can try to copy-paste base64 data url if your browser allows it) or select image file from local storage. Last changed input will be used as image source.<br />
    <input type="text" id="filelink" onChange="linkChange();" placeholder="Link to image" autofocus></input>
    <input type="file" id="filepath" onChange="fileChange(event);" title="Select local file" accept="image/*"></input><br />
    <input type="range" id="bpc_input" min="1" max="8" value="8" onChange="document.getElementById('bpc_input').title=document.getElementById('bpc_input').value.toString()+'bpc'; updateLabel()"></input>Number of bits per color. Same as number of bits per pixel divided by 4. minimum 1, maximum 8. Can be used as poor lossy compression.<br />
    <input type="text" id="xSize" value="100" onChange="document.getElementById('xSize').value=document.getElementById('xSize').value.replace(/[^0-9]/gi,'').padStart(1,'0'); updateLabel()">Maximum horizontal size of image in pixels.<br />Vertical size will be changed to save aspect ratio. Note that sometimes link itself already have "size", "width" or something like that.<br />
    <input type="text" id="pixelSize" value="1" onChange="document.getElementById('pixelSize').value=document.getElementById('pixelSize').value.replace(/[^0-9\.]/gi,'').padStart(1,'0'); updateLabel()">Size of each pixel in font units (em).<br />
    <input type="text" id="bgColor" value="" onChange="document.getElementById('bgColor').value=document.getElementById('bgColor').value.replace(/[^0-9A-Fa-f]/gi,'').slice(0,6); updateLabel()">Background i.e. color treated as transparent. 24bit hex without leading hash, e.g. <b>10FF80</b>, may be empty.<br />
    <p id="filename"></p><br /><img id="imageTag" style="display:none" /><canvas id="canvas"></canvas><br /><input type="text" id="textoutput"></input><i id="outputSize"></i><br />Output (i.e. code for label) will be in text field above.<br />Note that you must use Military font to get correct results.<br />If you're fine with not-so-correct results and your image is not transparent you can use any font except Roboto (Roboto font has different dash length and gives weird patterns on large images).
</body>
<script type="text/javascript">
function hexbyte(a){return Math.floor(a).toString(16).padStart(2, "0").toUpperCase()}

function toStr(a,size){return a.toPrecision(Math.ceil(3+Math.log10(size))).replace(/0*$/,"")}

function updateLabel(){
    var img = document.getElementById("imageTag");
    if (!img.complete){img.addEventListener('load',imgLoaded)}else{imgLoaded()}}

function fileChange(event){
    var img = document.getElementById("imageTag");
    img.src = URL.createObjectURL(event.target.files[0]);
    img.crossOrigin = "anonymous";
    document.getElementById("filename").innerHTML = "file: "+event.target.files[0].name;
    updateLabel()
}

function linkChange(){
    var img = document.getElementById("imageTag");
    var link = document.getElementById("filelink").value;
    img.src = link;
    img.crossOrigin = "anonymous";
    if(link.length<=250&&!link.startsWith("data:")){document.getElementById("filename").innerHTML = link;}
    else{document.getElementById("filename").innerHTML = link.substring(0,100)+"...";}
    updateLabel()
}

function colorStr(r,g,b,a){
    c=hexbyte(r)+hexbyte(g)+hexbyte(b)+(a=255?"":hexbyte(a))//it's very simple idea:don't write alpha if it's equal to default.
    //why did it took many months for me to think about it?
    if(c.length>=8){return "<#"+((c[1]==c[0]&&c[3]==c[2]&&c[5]==c[4]&&c[7]==c[6])?c[0]+c[2]+c[4]+c[6]:c)+">"}
    else{return "<#"+((c[1]==c[0]&&c[3]==c[2]&&c[5]==c[4])?c[0]+c[2]+c[4]:c)+">"}
    //if least-significant digits aren't used write it as 16-bit color
    //you can rarely see 16-bit colors in real images but it can save some kilobytes if mask was used
    }

function hexToColor(s){
    r=parseInt(s.slice(0,2),16)
    g=parseInt(s.slice(2,4),16)
    b=parseInt(s.slice(4,6),16)
    if(r===r&&r!=undefined&&g===g&&g!=undefined&&b===b&&b!=undefined){return [r,g,b]}
    else{return undefined}
    }

function imgLoaded(){
    var img = document.getElementById("imageTag");
    if (!img.complete){return}
    var mask=255<<(8-document.getElementById("bpc_input").value)&255;
    var xSize=parseInt(document.getElementById("xSize").value.replace(/[^0-9]/gi,"").padStart(1,"0"),10);
    var canvas = document.getElementById("canvas");
    var context = canvas.getContext("2d");
    img.width=Math.min(img.naturalWidth,xSize); img.height=(img.naturalHeight/img.naturalWidth*img.width);
    canvas.width = img.width; canvas.height = img.height; context.drawImage(img,0,0,img.width,img.height);
    var imageData = context.getImageData(0,0,img.width,img.height);
    var bgColor=hexToColor(document.getElementById("bgColor").value)
    if(bgColor!=undefined){bgColor[0]=(bgColor[0]&mask)*255/mask;bgColor[1]=(bgColor[1]&mask)*255/mask;bgColor[2]=(bgColor[2]&mask)*255/mask}
    var data=context.createImageData(img.width,img.height)
    for(let i=0;i<imageData.data.length;i++){data.data[i]=(imageData.data[i]&mask)*255/mask}
    if(bgColor!=undefined){for(let i=0;i<data.data.length;i+=4){if(data.data[i]==bgColor[0]&&data.data[i+1]==bgColor[1]&&data.data[i+2]==bgColor[2]){data.data[i+3]=0}}}
    context.putImageData(data,0,0); delete imageData
    var r,g,b,a=0;
    var rp=[-1]; var gp=[-1]; var bp=[-1]; var ap=[-1]; var count=[0]; i=0;
    for(let y=0; y<img.height;y+=1){
        for(let x=0; x<(img.width);x+=1){
            r=data.data[(y*img.width+x)*4];
            g=data.data[(y*img.width+x)*4+1];
            b=data.data[(y*img.width+x)*4+2];
            a=data.data[(y*img.width+x)*4+3];
            if((r!=rp[i-1]||g!=gp[i-1]||b!=bp[i-1]||a!=ap[i-1])&&!(a==0&&ap==0)){
                rp[i]=r;gp[i]=g;bp[i]=b;ap[i]=a;count[i]=1;i+=1
            }
            else {count[i-1]+=1}
        }
        rp[i]=-1;gp[i]=-1;bp[i]=-1;ap[i]=-1;count[i]=0;i+=1;
    }
    var pixelSize=parseFloat(document.getElementById("pixelSize").value)
    var size=pixelSize*10.5;var dashSize=29.5/2;var sDashSize=8+1/4.5
    var label="<align=left><mspace="+toStr(pixelSize,1)+"em><line-height="+toStr(pixelSize,1)+"em><size="+toStr(size,1)+"em>";
    var c="";var n=""
    len=count.length-1
    while(Math.max(0,i--)){
        if(count[len-i]==0){label+="<br>"}//linefeed
        else if(ap[len-i]==0&&count[len-i+1]!=0){label+=((count[len-i]>=15)?"<space="+toStr(count[len-i]/10.5,size)+"em>":(" ".repeat(count[len-i])));}//transparent
        //transparent pixels at end of line are truncated. 15 because "<space=00.00px>" is 15 char.-long
        else if(ap[len-i]==255&&count[len-i]>=45){//it will write entire color even if nothing except alpha was changed because "<#000000FF>" isn't longer than "<alpha=#FF>"
            n=colorStr(rp[len-i],gp[len-i],bp[len-i],ap[len-i]);
            if(c!=n){c=n;label+=c}
            var ldl=Math.floor(Math.floor(count[len-i]/dashSize)*dashSize)
            var sdl=Math.floor(Math.floor((count[len-i]-ldl)/sDashSize)*sDashSize)
            label+="<space="+toStr((ldl+sdl)/10.5,size)+"em>"+".".repeat(count[len-i]-ldl-sdl);
        }
        else if(ap[len-i]!=0){
            n=colorStr(rp[len-i],gp[len-i],bp[len-i],ap[len-i]);
            if(c!=n){c=n;label+=c}
            label+=".".repeat(count[len-i]);
        }
    }
    label=label.replaceAll(/((?:<br>){11,})/g,function(m){return m.length<11?m:"<line-height="+toStr(m.length*pixelSize/4/size,1)+"em><br><line-height="+toStr(pixelSize/size,1)+"em>"})
    size=pixelSize*14.8
    label+="</size></mspace><line-height="+toStr(-pixelSize*(1+img.height),1)+"em><br><line-height="+toStr(pixelSize,1)+"em><size="+toStr(size,1)+"em><voffset=-.222em><br>"
    i=1+len;var space=0;var c="";var n=""
    while(Math.max(0,i--)){
        if(count[len-i]==0){label+="<br>";space=0}//linefeed
        else if(ap[len-i]==255&&count[len-i]>=45){
            label+="<space="+toStr(space/14.8,size)+"em>"
            var ldl=Math.floor(count[len-i]/dashSize)
            var sdl=Math.floor((count[len-i]-ldl*dashSize)/sDashSize)
            space=count[len-i]-ldl*dashSize-sdl*sDashSize
            n=colorStr(rp[len-i],gp[len-i],bp[len-i],ap[len-i]);
            if(c!=n){c=n;label+=c}
            label+="—".repeat(ldl)+"‒".repeat(sdl)
        }
        else{space+=count[len-i]}
    }
    label=label.replace(/<[^<>]*>(?:<br>){2,}$/,"").replaceAll(/((?:<br>){11,})/g,function(m){return m.length<11?m:"<line-height="+toStr(m.length*pixelSize/4/size,1)+"em><br><line-height="+toStr(pixelSize/size,1)+"em>"})
    document.getElementById("textoutput").value=label
    document.getElementById("outputSize").textContent=label.length.toString()+"bytes"
}
</script>
</html>
